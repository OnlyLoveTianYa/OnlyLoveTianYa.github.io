---
layout: post
title:  JVM垃圾回收算法总结
date:   2017-07-19 22:08:00 +0800
categories: GC总结
---

* content
{:toc}


前言
====================================
经常在知乎看到别人推荐《深入理解JVM虚拟机》这本书，而且自己对JAVA的内存结构以及CLASS文件到底存的是什么有些疑惑，所以买这本书来看看，嗯，这本书确实写的很好，真的强推大家也买一本看看。我觉得对我的帮助不下于《JAVA编程思想》，书买了有半个月了，也粗略的读了读，一直想写一篇文章分享一下收获，今天拖延症终于没法做，哈哈。。。


JVM内存结构？JVM如何回收内存？
====================================
大家都知道JAVA会自动进行无用对象的清除，这就是JVM的垃圾回收的作用。垃圾回收有这三个问题
 1、判断那些对象是垃圾？ 2、什么时候回收垃圾？ 3、怎样回收垃圾？
 一、引用计数法和可达性分析两种算法可以判断一个对象是否被其他对象引用，不被任何一个对象引用的对象肯定就是垃圾了。因为引用计数法存在循环引用等缺点，现在的GC算法都是使用可达性分析算法来判断垃圾。
 可达性分析算法是从ROOT对象开始遍历，没有被遍历到的对象就是垃圾。可作为root对象的有（虚拟机栈中引用的对象、方法区类静态属性引用的对象、方法区常量引用的对象、本地方法JNI引用的对象）
 二、说到什么时候回收垃圾，先要说一下JVM的内存结构吧，以JDK1.7为例在HotSpotVM中内存分为
 方法区（线程共享）、堆（线程共享）、虚拟机栈、本地方法栈、程序计数器。而堆中又分为新生代和老年代。新生代由eden和from survivor和to survivor三块组成默认比例为8：1：1这样是的新生代的内存利用率为90%。对象new出来首先在eden区分配（大对象直接进入老年代）当eden区域内存不足时会发生一次Major GC,对新生代进行垃圾回收（由于新生代对象是垃圾概率很高，所以采用的是复制清除算法）发生Minor  GC之后 survivor区达到足够年龄（默认15）的对象可以进入老年代（动态年龄判定：survivor区空间所有相同年龄的对象大小总和大于一个survivor空间的一半，年龄大于或等于该空间的对象就直接进入老年代，不需要等到MaxTenurinThreshold中要求的年龄），但是如果发生Major GC之后 survivor区域对象还放不下eden区域的对象，这时候就使用分配担保机制使对象进入老年代。当老年代对象满了之后就会发生Major GC,会对整个堆以及方法区都进行垃圾回收。
 三、如何回收对象？由于新生代和年老代的对象的不同特点，虚拟机采用分代回收，即新生区使用复制清除算法，年老代使用标记清除和标记整理两种。
下载

GC算法有哪些？特点是什么？
====================================
新生代GC有：1、Serial(顺序单线程) 2、ParNew(多线程) 3、Paraller Scavenge(吞吐量优先，并行)
老年代GC有：1、CMS（并发标记清除） 2、Serial Old(单线程) 3、Paraller Old（吞吐量优先，多线程）
特殊 G1（新型收集器，可收集年老和新生代，最有潜力的收集器，还在完善。特点分块回收，先计算块的回收价值）

今天先说到这把~
